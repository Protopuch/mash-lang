// strings.mash

uses <bf>

proc c_Ord(.char):
  push .char
  chord
  gpm
end


proc c_Chr(.wrd):
  push .wrd
  ordch
  gpm
end


proc s_At(.s, .index):
  push .index
  push .s
  stchatp
  gpm
end


proc s_Set(.s, .index, .char):
  push .index
  push .char
  push .s
  stchatk
end


proc s_Len(.s):
  push .s
  strl
  gpm
end


proc s_Del(.s, .from, .count):
  push .from
  push .count
  push .s
  strd
end


func s_Copy(.s, .from, .count):
  var .r = copy(.s)
  s_del(.r, .from + .count + 1, s_len(.r))
  s_del(.r, 1, .from - 1)
  return .r
end


func s_Reverse(.s):
  var .r = copy(.s), .i, .l = s_len(.r), .ch
  if .l > 0:
    for(.i ?= 1; .i < (.l \ 2); inc .i):
      .ch ?= s_at(.r, .l - .i + 1)
      s_set(.r, .l - .i + 1, s_at(.r, .i))
      s_set(.r, .i, .ch)
    end
  end
  return .r
end


func s_LeftStr(.s, .count):
  return s_copy(.s, 1, .count)
end


func s_RightStr(.s, .count):
  return s_copy(.s, s_len(.s) - .count + 1, .count)
end


func s_Pos(.sb, .s):
  var .p, .t, .t2, .l, .sub_l, .b

  .l ?= s_len(.s)
  .sub_l ?= s_len(.sb)

  .b ?= false
  .p ?= 1
  while .p < .l:
    if .b:
      return .p - 1
    end

    .b = false

    if s_at(.sb, 1) == s_at(.s, .p):
      .b = true
      .t2 ?= copy(.p)
      for (.t ?= 2; .t < .sub_l; inc .t):
        inc .t2
        if ~(s_at(.sb, .t) == s_at(.s, .t2)):
          .b = false
          break
        end
      end

      if ~.b:
        .p = .t2
      end
    end

    inc .p
  end
  return 0
end


func s_PosEx(.sb, .s, .num):
  var .p, .t, .t2, .l, .sub_l, .b

  .l ?= s_len(.s)
  .sub_l ?= s_len(.sb)

  .b ?= false
  .p ?= 1
  while .p < .l:
    if .b:
      if .num > 1:
        dec .num
      else:
        return .p - 1
      end
    end

    .b = false

    if s_at(.sb, 1) == s_at(.s, .p):
      .b = true
      .t2 ?= copy(.p)
      for (.t ?= 2; .t < .sub_l; inc .t):
        inc .t2
        if ~(s_at(.sb, .t) == s_at(.s, .t2)):
          .b = false
          break
        end
      end

      if ~.b:
        .p = .t2
      end
    end

    inc .p
  end
  return 0
end


func s_TrimLeft(.s):
  var .r = copy(.s)
  while s_len(.r) > 0:
    if s_at(.r, 1) == " ":
      s_del(.r, 1, 1)
    else:
      break
    end
  end
  return .r
end


func s_TrimRight(.s):
  var .r = copy(.s)
  while s_len(.r) > 0:
    if s_at(.r, s_len(.r)) == " ":
      s_del(.r, s_len(.r), 1)
    else:
      break
    end
  end
  return .r
end


func s_Trim(.s):
  var .r = copy(.s)
  .r = s_trimright(.r)
  .r = s_trimleft(.r)
  return .r
end


enum s_ReplaceFlags [srfReplaceFirst, srfReplaceAll, srfIgnoreCase]

func s_Replace(.s, .from, .to, .flags):
  var .r = copy(.s), .p
  .p ?= s_Pos(.from, .r)
  while .p > 0:
    //.r
    .p = s_Pos(.from, .r)
  end
  return .r
end

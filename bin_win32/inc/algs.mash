// Module with some algorithms

uses <bf>
uses <threads>

/*
 *  Quick sorting algorithm implementation.
 */

proc FromToQSort(arr, left, right):
  i ?= left
  j ?= right
  pivot ?= arr[(left + right) \ 2]

  while i < (j + 1):
    while arr[i] < pivot:
      i++
    end

    while arr[j] > pivot:
      j--
    end

    if i < (j + 1):
      tmp ?= arr[i]
      arr[i] ?= arr[j]
      arr[j] ?= tmp
      i++
      j--
    end
  end

  if left < j:
    FromToQSort(arr, left, j)
  end

  if i < right:
    FromToQSort(arr, i, right)
  end
end

proc QuickSort(arr):
  FromToQSort(arr, 0, len(arr) - 1)
end

/*
 *  Multithreaded Quick sorting algorithm implementation.
 */

proc FromToThrQSort(arr, left, right, lvl, maxlvl):
  i ?= left
  j ?= right
  pivot ?= arr[(left + right) \ 2]

  while i < (j + 1):
    while arr[i] < pivot:
      i++
    end

    while arr[j] > pivot:
      j--
    end

    if i < (j + 1):
      tmp ?= arr[i]
      arr[i] ?= arr[j]
      arr[j] ?= tmp
      i++
      j--
    end
  end

  if lvl < maxlvl:
    if left < j:
      ThrL ?= Parallel(FromToThrQSort, arr, copy(left), copy(j), lvl + 1, maxlvl)
    end

    if i < right:
      ThrR ?= Parallel(FromToThrQSort, arr, copy(i), copy(right), lvl + 1, maxlvl)
    end

    try:
      ThrL -> WaitFor()
      ThrR -> WaitFor()
      ThrL -> Free()
      ThrR -> Free()
    catch:
      pop
    end
  else:
    if left < j:
      FromToThrQSort(arr, left, j, lvl, maxlvl)
    end

    if i < right:
      FromToThrQSort(arr, i, right, lvl, maxlvl)
    end
  end
end

proc ThrQuickSort(arr, maxthr):
  FromToThrQSort(arr, 0, len(arr) - 1, 0, maxthr \ 2)
end

/*
 *  Heap sorting algorithm implementation.
 */

proc HeapSortTo(arr, n):
  i ?= n / 2

  while true:
    if i > 0:
      i--
      t ?= arr[i]
    else:
      n--
      if n == 0:
        exit
      end
      t ?= arr[n]
      arr[n] ?= arr[0]
    end

    parent ?= i
    child ?= i * 2 + 1

    while child < n:
      if (child + 1 < n) & (arr[child + 1] > arr[child]):
        child++
      end

      if arr[child] > t:
        arr[parent] ?= arr[child]
        parent ?= child
        child ?= parent * 2 + 1
      else:
        break
      end
    end
    arr[parent] ?= t
  end
end

proc HeapSort(arr):
  HeapSortTo(arr, len(arr) - 1)

  n ?= len(arr) - 1
  t ?= arr[n]
  for (i ?= n; i > 0; i--):
    arr[i] ?= arr[i - 1]
  end
  arr[0] ?= t
end

/*
 *  Binary search
 */

func FromToBinSearch(arr, left, right, key):
  while true:
    midd ?= (left + right) \ 2

    if key < arr[midd]:
      right ?= midd - 1
    else:
      if key > arr[midd]:
        left ?= midd + 1
      else:
        return midd
      end
    end

    if left > right:
      return -1
    end
  end
end

func BinSearch(arr, key):
  l ?= len(arr)
  if l > 0:
    return FromToBinSearch(arr, 0, l - 1, key)
  else:
    return -1
  end
end

func FromToBinNext(arr, left, right, key):
  while true:
    midd ?= (left + right) \ 2

    if key < arr[midd]:
      right ?= midd - 1
    else:
      if key > arr[midd]:
        left ?= midd + 1
      else:
        return midd
      end
    end

    if left > right:
      return midd
    end
  end
end

func BinNext(arr, key):
  l ?= len(arr)
  if l > 0:
    r ?= FromToBinNext(arr, 0, l - 1, key)
    if arr[r] > key:
      return r
    else:
      return r + 1
    end
  else:
    return 0
  end
end

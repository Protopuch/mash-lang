// Base functions & SVMEXE Initialization.

import I2S          "bf.lib" "INTTOSTR"
import F2S          "bf.lib" "FLOATTOSTR"
import S2I          "bf.lib" "STRTOINT"
import S2F          "bf.lib" "STRTOFLOAT"
import Halt         "bf.lib" "HALT"
import Sleep        "bf.lib" "SLEEP"
import StrUpper     "bf.lib" "STRUPPER"
import StrLower     "bf.lib" "STRLOWER"
import ChrUpper     "bf.lib" "CHRUPPER"
import ChrLower     "bf.lib" "CHRLOWER"
import Now          "bf.lib" "CURRENTDATETIME"
import Randomize    "bf.lib" "RANDOMIZE"
import Random       "bf.lib" "RANDOM"
import RandomB      "bf.lib" "RANDOMB"
import TickCnt      "bf.lib" "TICKCNT"

// Global values
int  true  -1
int  false  0

var null = "null"

func BoolToStr(.b):
  if .b == true:
    return "true"
  else:
    return "false"
  end
end

proc ExitThread():
  threxit
end

func new(.value):
  var .v = new
  .v = .value
  return .v
end

func copy(.value):
  push .value
  copy
  gpm
  pop .value
  return .value
end

func ArrLen(.array):
  push .array
  alen
  gpm
  var .len
  pop .len
  return .len
end

proc SetArrLen(.array, .newlen):
  push .array
  push .newlen
  salen
  pop
end

proc FreeArr(.array):
  push .array
  gpa
  pop
end

proc Free(.simple_object):
  push .simple_object
  rem
end

proc FreeClass(.object):
  .object->StructFree()
  SetArrLen(.object, 0)
//  push .object
//  gpa
//  pop
end

proc thread(.method, .arg):
  push .arg
  push .method
  cthr
end

proc async(.method, .arg):
  push .arg
  push .method
  cthr
  pcopy
  rthr
end

proc thr_resume(.thread):
  push .thread
  rthr
end

proc thr_suspend(.thread):
  push .thread
  sthr
end

proc thr_terminate(.thread):
  push .thread
  tthr
end

func In(.v, .array):
  var .i, .len
  .len ?= arrlen(.array) - 1
  for (.i ?= 0; .i < .len; inc .i):
    if .array[.i] == .v:
      return true
    end
  end
  return false
end

func temp():
  return 0
end

proc GetError():
  //err already in stack
end

proc Exit():
  jr
end

proc super.Exit():
  jr
end

proc super.ExitThread():
  jump !__haltpoint
end

proc __EntryPoint():
  Main()
  gc
end

proc gpm(.v):
  push .v
  gpm
end
